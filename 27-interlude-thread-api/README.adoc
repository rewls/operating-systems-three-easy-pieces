= 27 Interlude: Thread API
:figure-caption: Figure 27.
:toc: left

* This chapter briefly covers the main portions of the thread API.
* Each part will be explained further in the subsequent chapters, as we show
  how to use the API.
* More details can be found in various books and online sources [B89, B97,
  B+96, K+96].
* We should note that the subsequent chapters introduce the concepts of locks
  and condition variables more slowly, with many examples; this chapter is
  thus better used as a reference.

.Crux: How to create and control threads
****
* What interfaces should the OS present for thread creation and control?
* How should these interfaces be designed to enable ease of use as well as
  utility?
****

== 27.1 Thread Creation

* The first thing you have to be able to do to write a multi-threaded program
  is to create new threads, and thus some kind of thread creation interface
  must exist.
* In POSIX, it is easy:

[source,c]
#include <pthread.h>
int
pthread_create(pthread_t *thread,
		const pthread_attr_t *attr,
		void *(*start_routine)(void*),
		void *arg);

'''

* This declaration might look a little complex (particularly if you haven't
  used function pointers in C), but actually it's not too bad.
* There are four arguments: `thread`, `attr`, `start_routine`, and `arg`.
* The first, `thread`, is a pointer to a structure of type `pthread_t`; we'll
  use this structure to interact with this thread, and thus we need to pass it
  to `pthread_create()` in order to initialize it.

'''

* The second argument, `attr`, is used to specify any attributes this thread
  might have.
* Some examples include setting the stack size or perhaps information about
  the scheduling priority of the thread.
* An attribute is initialized with a separate call to `pthread_attr_init()`;
  see the manual page for details.
* However, in most cases, the defaults will be fine; in this case, we will
  simply pass the value `NULL` in.

'''

* The third argument is the most complex, but is really just asking: which
  function should this thread start running in?
* In C, we call this a function pointer, and this one tells us the following
  is expected: a function name (start routine), which is passed a single
  argument of type `void *` (as indicated in the parentheses after start
  routine), and which returns a value of type `void *` (i.e., a *void
  pointer*).

'''

* If this routine instead required an integer argument, instead of a void
  pointer, the declaration would look like this:

[source,c]
int pthread_create(..., // first two args are the same
		void *(*start_routine)(int),
		int arg);

* If instead the routine took a void pointer as an argument, but returned
an integer, it would look like this:

[source,c]
int pthread_create(..., // first two args are the same
		int (*start_routine)(void *),
		void *arg);

'''

* Finally, the fourth argument, `arg`, is exactly the argument to be passed to
  the function where the thread begins execution.
* You might ask: why do we need these void pointers?
* Well, the answer is quite simple: having a void pointer as an argument to
  the function start routine allows us to pass in any type of argument; having
  it as a return value allows the thread to return any type of result.

'''

* Let's look at an example in Figure 27.1.
* Here we just create a thread that is passed two arguments, packaged into a
  single type we define ourselves (`myarg_t`).
* The thread, once created, can simply cast its argument to the type it
  expects and thus unpack the arguments as desired.

:figure-number: 1
.{figure-caption} {figure-number}. Creating a Thread
[,c]
----
#include <stdio.h>
#include <pthread.h>

typedef struct {
    int a;
    int b;
} myarg_t;

void *mythread(void *arg) {
    myarg_t *args = (myarg_t *) arg;
    printf("%d %d\n", args->a, args->b);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    myarg_t args = { 10, 20 };

    int rc = pthread_create(&p, NULL, mythread, &args);
    ...
}
----

* And there it is!
* Once you create a thread, you really have another live executing entity,
  complete with its own call stack, running within the same address space as
  all the currently existing threads in the program.
* The fun thus begins!

== 27.2 Thread Completion

* The example above shows how to create a thread.
* However, what happens if you want to wait for a thread to complete?
* You need to do something special in order to wait for completion; in
  particular, you must call the routine `pthread_join()`.

[source,c]
int pthread_join(pthread_t thread, void **value_ptr);

* This routine takes two arguments.
* The first is of type `pthread_t`, and is used to specify which thread to
  wait for.
* This variable is initialized by the thread creation routine (when you pass a
  pointer to it as an argument to `pthread_create()`); if you keep it around,
  you can use it to wait for that thread to terminate.

'''

* The second argument is a pointer to the return value you expect to get back.
* Because the routine can return anything, it is defined to return a pointer
  to void; because the `pthread_join()` routine changes the value of the passed
  in argument, you need to pass in a pointer to that value, not just the value
  itself.

'''

* Let's look at another example (Figure 27.2, page 4).
* In the code, a single thread is again created, and passed a couple of
  arguments via the `myarg_t` structure.
* To return values, the `myret_t` type is used.
* Once the thread is finished running, the main thread, which has been waiting
  inside of the `pthread_join()` routine{empty}footnote:[Note we use wrapper
  functions here; specifically, we call `Malloc()`, `Pthread_join()`, and
  `Pthread_create()`, which just call their similarly-named lower-case
  versions and make sure the routines did not return anything unexpected.],
  then returns, and we can access the values returned from the thread, namely
  whatever is in `myret_t`.

:figure-number: 2
.{figure-caption} {figure-number}. Waiting for Thread Completion
[,c]
----
include::thread_create.c[]
----

* A few things to note about this example.
* First, often times we don't have to do all of this painful packing and
  unpacking of arguments.
* For example, if we just create a thread with no arguments, we can pass
  `NULL` in as an argument when the thread is created.
* Similarly, we can pass `NULL` into `pthread_join()` if we don't care about
  the return value.

'''

* Second, if we are just passing in a single value (e.g., a `long long int`),
  we don't have to package it up as an argument.
* Figure 27.3 (page 5) shows an example.
* In this case, life is a bit simpler, as we don't have to package arguments
  and return values inside of structures.

:figure-number: 3
.{figure-caption} {figure-number}. Simpler Argument Passing to a Thread
[,c]
----
include::thread_create_simple_args.c[]
----

* Third, we should note that one has to be extremely careful with how values
  are returned from a thread.
* Specifically, never return a pointer which refers to something allocated on
  the thread's call stack.
* If you do, what do you think will happen?
* (think about it!)
* Here is an example of a dangerous piece of code, modified from the example
  in Figure 27.2.

[,c]
----
void *mythread(void *arg) {
	myarg_t *args = (myarg_t *) arg;
	printf("%d %d\n", args->a, args->b);
	myret_t oops; // ALLOCATED ON STACK: BAD!
	oops.x = 1;
	oops.y = 2;
	return (void *) &oops;
}
----

* In this case, the variable `oops` is allocated on the stack of `mythread`.
* However, when it returns, the value is automatically deallocated (that's why
  the stack is so easy to use, after all!), and thus, passing back a pointer
  to a now deallocated variable will lead to all sorts of bad results.
* Certainly, when you print out the values you think you returned, you'll
  probably (but not necessarily!) be surprised.
* Try it and find out for yourself{empty}footnote:[Fortunately the compiler
  `gcc` will likely complain when you write code like this, which is yet
  another reason to pay attention to compiler warnings.]!

'''

* Finally, you might notice that the use of `pthread_create()` to create a
  thread, followed by an immediate call to `pthread_join()`, is a pretty
  strange way to create a thread.
* In fact, there is an easier way to accomplish this exact task; it's called a
  *procedure call*.
* Clearly, we'll usually be creating more than just one thread and waiting for
  it to complete, otherwise there is not much purpose to using threads at all.

'''

* We should note that not all code that is multi-threaded uses the join
  routine.
* For example, a multi-threaded web server might create a number of worker
  threads, and then use the main thread to accept requests and pass them to
  the workers, indefinitely.
* Such long-lived programs thus may not need to join.
* However, a parallel program that creates threads to execute a particular
  task (in parallel) will likely use join to make sure all such work completes
  before exiting or moving onto the next stage of computation.

== References

[B89] "An Introduction to Programming with Threads" by Andrew D. Birrell. DEC Technical Report, January, 1989. Available: https://birrell.org/andrew/papers/035-Threads.pdf::
* A classic but older introduction to threaded programming.
* Still a worthwhile read, and freely available.

[B97] "Programming with POSIX Threads" by David R. Butenhof. Addison-Wesley, May 1997.::
* Another one of these books on threads.

[B+96] "PThreads Programming: by A POSIX Standard for Better Multiprocessing.  " Dick Buttlar, Jacqueline Farrell, Bradford Nichols. O'Reilly, September 1996::
* A reasonable book from the excellent, practical publishing house O'Reilly.
* Our bookshelves certainly contain a great deal of books from this company,
  including some excellent offerings on Perl, Python, and Javascript
  (particularly Crockford's "Javascript: The Good Parts".)

[K+96] "Programming With Threads" by Steve Kleiman, Devang Shah, Bart Smaalders. Prentice Hall, January 1996.::
* Probably one of the better books in this space.
* Get it at your local library.
* Or steal it from your mother.
* More seriously, just ask your mother for it -- she'll let you borrow it,
  don't worry.
