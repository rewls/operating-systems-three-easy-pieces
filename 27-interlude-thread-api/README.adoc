= 27 Interlude: Thread API
:figure-caption: Figure 27.
:source-highlighter: rouge
:tabsize: 8
:toc: left

* This chapter briefly covers the main portions of the thread API.
* Each part will be explained further in the subsequent chapters, as we show
  how to use the API.
* More details can be found in various books and online sources [B89, B97,
  B+96, K+96].
* We should note that the subsequent chapters introduce the concepts of locks
  and condition variables more slowly, with many examples; this chapter is
  thus better used as a reference.

.Crux: How to create and control threads
****
* What interfaces should the OS present for thread creation and control?
* How should these interfaces be designed to enable ease of use as well as
  utility?
****

== 27.1 Thread Creation

* The first thing you have to be able to do to write a multi-threaded program
  is to create new threads, and thus some kind of thread creation interface
  must exist.
* In POSIX, it is easy:

[source,c]
#include <pthread.h>
int
pthread_create(pthread_t *thread,
		const pthread_attr_t *attr,
		void *(*start_routine)(void*),
		void *arg);

'''

* This declaration might look a little complex (particularly if you haven't
  used function pointers in C), but actually it's not too bad.
* There are four arguments: `thread`, `attr`, `start_routine`, and `arg`.
* The first, `thread`, is a pointer to a structure of type `pthread_t`; we'll
  use this structure to interact with this thread, and thus we need to pass it
  to `pthread_create()` in order to initialize it.

'''

* The second argument, `attr`, is used to specify any attributes this thread
  might have.
* Some examples include setting the stack size or perhaps information about
  the scheduling priority of the thread.
* An attribute is initialized with a separate call to `pthread_attr_init()`;
  see the manual page for details.
* However, in most cases, the defaults will be fine; in this case, we will
  simply pass the value `NULL` in.

'''

* The third argument is the most complex, but is really just asking: which
  function should this thread start running in?
* In C, we call this a function pointer, and this one tells us the following
  is expected: a function name (start routine), which is passed a single
  argument of type `void *` (as indicated in the parentheses after start
  routine), and which returns a value of type `void *` (i.e., a *void
  pointer*).

'''

* If this routine instead required an integer argument, instead of a void
  pointer, the declaration would look like this:

[source,c]
int pthread_create(..., // first two args are the same
		void *(*start_routine)(int),
		int arg);

* If instead the routine took a void pointer as an argument, but returned
an integer, it would look like this:

[source,c]
int pthread_create(..., // first two args are the same
		int (*start_routine)(void *),
		void *arg);

'''

* Finally, the fourth argument, `arg`, is exactly the argument to be passed to
  the function where the thread begins execution.
* You might ask: why do we need these void pointers?
* Well, the answer is quite simple: having a void pointer as an argument to
  the function start routine allows us to pass in any type of argument; having
  it as a return value allows the thread to return any type of result.

'''

* Let's look at an example in Figure 27.1.
* Here we just create a thread that is passed two arguments, packaged into a
  single type we define ourselves (`myarg_t`).
* The thread, once created, can simply cast its argument to the type it
  expects and thus unpack the arguments as desired.

:figure-number: 1
.{figure-caption} {figure-number}. Creating a Thread
[,c]
----
#include <stdio.h>
#include <pthread.h>

typedef struct {
    int a;
    int b;
} myarg_t;

void *mythread(void *arg) {
    myarg_t *args = (myarg_t *) arg;
    printf("%d %d\n", args->a, args->b);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    myarg_t args = { 10, 20 };

    int rc = pthread_create(&p, NULL, mythread, &args);
    ...
}
----

* And there it is!
* Once you create a thread, you really have another live executing entity,
  complete with its own call stack, running within the same address space as
  all the currently existing threads in the program.
* The fun thus begins!

== 27.2 Thread Completion

* The example above shows how to create a thread.
* However, what happens if you want to wait for a thread to complete?
* You need to do something special in order to wait for completion; in
  particular, you must call the routine `pthread_join()`.

[source,c]
int pthread_join(pthread_t thread, void **value_ptr);

* This routine takes two arguments.
* The first is of type `pthread_t`, and is used to specify which thread to
  wait for.
* This variable is initialized by the thread creation routine (when you pass a
  pointer to it as an argument to `pthread_create()`); if you keep it around,
  you can use it to wait for that thread to terminate.

'''

* The second argument is a pointer to the return value you expect to get back.
* Because the routine can return anything, it is defined to return a pointer
  to void; because the `pthread_join()` routine changes the value of the passed
  in argument, you need to pass in a pointer to that value, not just the value
  itself.

'''

* Let's look at another example (Figure 27.2, page 4).
* In the code, a single thread is again created, and passed a couple of
  arguments via the `myarg_t` structure.
* To return values, the `myret_t` type is used.
* Once the thread is finished running, the main thread, which has been waiting
  inside of the `pthread_join()` routine{empty}footnote:[Note we use wrapper
  functions here; specifically, we call `Malloc()`, `Pthread_join()`, and
  `Pthread_create()`, which just call their similarly-named lower-case
  versions and make sure the routines did not return anything unexpected.],
  then returns, and we can access the values returned from the thread, namely
  whatever is in `myret_t`.

:figure-number: 2
.{figure-caption} {figure-number}. Waiting for Thread Completion
[,c]
----
include::thread_create.c[]
----

* A few things to note about this example.
* First, often times we don't have to do all of this painful packing and
  unpacking of arguments.
* For example, if we just create a thread with no arguments, we can pass
  `NULL` in as an argument when the thread is created.
* Similarly, we can pass `NULL` into `pthread_join()` if we don't care about
  the return value.

'''

* Second, if we are just passing in a single value (e.g., a `long long int`),
  we don't have to package it up as an argument.
* Figure 27.3 (page 5) shows an example.
* In this case, life is a bit simpler, as we don't have to package arguments
  and return values inside of structures.

:figure-number: 3
.{figure-caption} {figure-number}. Simpler Argument Passing to a Thread
[,c]
----
include::thread_create_simple_args.c[]
----

* Third, we should note that one has to be extremely careful with how values
  are returned from a thread.
* Specifically, never return a pointer which refers to something allocated on
  the thread's call stack.
* If you do, what do you think will happen?
* (think about it!)
* Here is an example of a dangerous piece of code, modified from the example
  in Figure 27.2.

[,c]
----
void *mythread(void *arg) {
	myarg_t *args = (myarg_t *) arg;
	printf("%d %d\n", args->a, args->b);
	myret_t oops; // ALLOCATED ON STACK: BAD!
	oops.x = 1;
	oops.y = 2;
	return (void *) &oops;
}
----

* In this case, the variable `oops` is allocated on the stack of `mythread`.
* However, when it returns, the value is automatically deallocated (that's why
  the stack is so easy to use, after all!), and thus, passing back a pointer
  to a now deallocated variable will lead to all sorts of bad results.
* Certainly, when you print out the values you think you returned, you'll
  probably (but not necessarily!) be surprised.
* Try it and find out for yourself{empty}footnote:[Fortunately the compiler
  `gcc` will likely complain when you write code like this, which is yet
  another reason to pay attention to compiler warnings.]!

'''

* Finally, you might notice that the use of `pthread_create()` to create a
  thread, followed by an immediate call to `pthread_join()`, is a pretty
  strange way to create a thread.
* In fact, there is an easier way to accomplish this exact task; it's called a
  *procedure call*.
* Clearly, we'll usually be creating more than just one thread and waiting for
  it to complete, otherwise there is not much purpose to using threads at all.

'''

* We should note that not all code that is multi-threaded uses the join
  routine.
* For example, a multi-threaded web server might create a number of worker
  threads, and then use the main thread to accept requests and pass them to
  the workers, indefinitely.
* Such long-lived programs thus may not need to join.
* However, a parallel program that creates threads to execute a particular
  task (in parallel) will likely use join to make sure all such work completes
  before exiting or moving onto the next stage of computation.

== 27.3 Locks

* Beyond thread creation and join, probably the next most useful set of
  functions provided by the POSIX threads library are those for providing
  mutual exclusion to a critical section via *locks*.
* The most basic pair of routines to use for this purpose is provided by the
  following:

[,c]
----
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
----

'''

* The routines should be easy to understand and use.
* When you have a region of code that is a *critical section*, and thus needs
  to be protected to ensure correct operation, locks are quite useful.
* You can probably imagine what the code looks like:

[source,c]
pthread_mutex_t lock;
pthread_mutex_lock(&lock);
x = x + 1; // or whatever your critical section is
pthread_mutex_unlock(&lock);

* The intent of the code is as follows: if no other thread holds the lock when
  `pthread_mutex_lock()` is called, the thread will acquire the lock and enter
  the critical section.
* If another thread does indeed hold the lock, the thread trying to grab the
  lock will not return from the call until it has acquired the lock (implying
  that the thread holding the lock has released it via the unlock call).
* Of course, many threads may be stuck waiting inside the lock acquisition
  function at a given time; only the thread with the lock acquired, however,
  should call unlock.

'''

* Unfortunately, this code is broken, in two important ways.
* The first problem is a lack of proper initialization.
* All locks must be properly initialized in order to guarantee that they have
  the correct values to begin with and thus work as desired when lock and
  unlock are called.

'''

* With POSIX threads, there are two ways to initialize locks.
* One way to do this is to use `PTHREAD_MUTEX_INITIALIZER`, as follows:

[source,c]
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

* Doing so sets the lock to the default values and thus makes the lock usable.
* The dynamic way to do it (i.e., at run time) is to make a call to
  `pthread_mutex_init()`, as follows:

[source,c]
int rc = pthread_mutex_init(&lock, NULL);
assert(rc == 0); // always check success!

* The first argument to this routine is the address of the lock itself,
  whereas the second is an optional set of attributes.
* Read more about the attributes yourself; passing `NULL` in simply uses the
  defaults.
* Either way works, but we usually use the dynamic (latter) method.
* Note that a corresponding call to `pthread_mutex_destroy()` should also be
  made, when you are done with the lock; see the manual page for all of the
  details.

'''

* The second problem with the code above is that it fails to check error codes
  when calling lock and unlock.
* Just like virtually any library routine you call in a UNIX system, these
  routines can also fail!
* If your code doesn't properly check error codes, the failure will happen
  silently, which in this case could allow multiple threads into a critical
  section.
* Minimally, use wrappers, which `assert` that the routine succeeded, as shown
  in Figure 27.4 (page 7); more sophisticated (non-toy) programs, which can't
  simply exit when something goes wrong, should check for failure and do
  something appropriate when a call does not succeed.

:figure-number: 4
.{figure-caption} {figure-number}. An Example Wrapper
[source,c]
// Keeps code clean; only use if exit() OK upon failure
void Pthread_mutex_lock(pthread_mutex_t *mutex) {
	int rc = pthread_mutex_lock(mutex);
	assert(rc == 0);
}

* The lock and unlock routines are not the only routines within the pthreads
  library to interact with locks.
* Two other routines of interest:

[source,c]
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_timedlock(pthread_mutex_t *mutex,
		struct timespec *abs_timeout);

* These two calls are used in lock acquisition.
* The `trylock` version returns failure if the lock is already held; the
  `timedlock` version of acquiring a lock returns after a timeout or after
  acquiring the lock, whichever happens first.
* Thus, the `timedlock` with a timeout of zero degenerates to the `trylock`
  case.
* Both of these versions should generally be avoided; however, there are a few
  cases where avoiding getting stuck (perhaps indefinitely) in a lock
  acquisition routine can be useful, as we'll see in future chapters (e.g.,
  when we study deadlock).

== 27.4 Condition Variables

* The other major component of any threads library, and certainly the case
  with POSIX threads, is the presence of a condition variable.
* Condition variables are useful when some kind of signaling must take place
  between threads, if one thread is waiting for another to do something before
  it can continue.
* Two primary routines are used by programs wishing to interact in this way:

[source,c]
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_signal(pthread_cond_t *cond);

* To use a condition variable, one has to in addition have a lock that is
  associated with this condition.
* When calling either of the above routines, this lock should be held.

'''

* The first routine, `pthread_cond_wait()`, puts the calling thread to sleep,
  and thus waits for some other thread to signal it, usually when something in
  the program has changed that the now-sleeping thread might care about.
* A typical usage looks like this:

[,c]
----
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

Pthread_mutex_lock(&lock);
while (ready == 0)
	Pthread_cond_wait(&cond, &lock);
Pthread_mutex_unlock(&lock);
----

'''

* In this code, after initialization of the relevant lock and
  condition{empty}footnote:[One can use `pthread_cond_init()` (and
  `pthread_cond_destroy()`) instead of the static initializer
  `PTHREAD_COND_INITIALIZER`. Sound like more work? It is.], a thread checks
  to see if the variable `ready` has yet been set to something other than
  zero.
* If not, the thread simply calls the wait routine in order to sleep until
  some other thread wakes it.

'''

* The code to wake a thread, which would run in some other thread, looks like
  this:
+
[source,c]
Pthread_mutex_lock(&lock);
ready = 1;
Pthread_cond_signal(&cond);
Pthread_mutex_unlock(&lock);

'''

* A few things to note about this code sequence.
* First, when signaling (as well as when modifying the global variable
  `ready`), we always make sure to have the lock held.
* This ensures that we don't accidentally introduce a race condition into our code.

'''

* Second, you might notice that the wait call takes a lock as its second
  parameter, whereas the signal call only takes a condition.
* The reason for this difference is that the wait call, in addition to putting
  the calling thread to sleep, _releases_ the lock when putting said caller to
  sleep.
* Imagine if it did not: how could the other thread acquire the lock and
  signal it to wake up?
* However, _before_ returning after being woken, the `pthread_cond_wait()`
  re-acquires the lock, thus ensuring that any time the waiting thread is
  running between the lock acquire at the beginning of the wait sequence, and
  the lock release at the end, it holds the lock.

'''

* One last oddity: the waiting thread re-checks the condition in a while loop,
  instead of a simple if statement.
* We'll discuss this issue in detail when we study condition variables in a
  future chapter, but in general, using a while loop is the simple and safe
  thing to do.
* Although it rechecks the condition (perhaps adding a little overhead), there
  are some pthread implementations that could spuriously wake up a waiting
  thread; in such a case, without rechecking, the waiting thread will continue
  thinking that the condition has changed even though it has not.
* It is safer thus to view waking up as a hint that something might have
  changed, rather than an absolute fact.

'''

* Note that sometimes it is tempting to use a simple flag to signal between
  two threads, instead of a condition variable and associated lock.
* For example, we could rewrite the waiting code above to look more like this
  in the waiting code:

[source,c]
while (ready == 0)
	; // spin

* The associated signaling code would look like this:

[source,c]
ready = 1;

* Don't ever do this, for the following reasons.
* First, it performs poorly in many cases (spinning for a long time just
  wastes CPU cycles).
* Second, it is error prone.
* As recent research shows [X+10], it is surprisingly easy to make mistakes
  when using flags (as above) to synchronize between threads; in that study,
  roughly half the uses of these ad hoc synchronizations were buggy!
* Don't be lazy; use condition variables even when you think you can get away
  without doing so.

'''

* If condition variables sound confusing, don't worry too much (yet) -- we'll
  be covering them in great detail in a subsequent chapter.
* Until then, it should suffice to know that they exist and to have some idea
  how and why they are used.

== 27.5 Compiling and Running

* All of the code examples in this chapter are relatively easy to get up and
  running.
* To compile them, you must include the header `pthread.h` in your code.
* On the link line, you must also explicitly link with the pthreads library,
  by adding the `-pthread` flag.

'''

* For example, to compile a simple multi-threaded program, all you have to do
  is the following:

....
prompt> gcc -o main main.c -Wall -pthread
....

* As long as `main.c` includes the pthreads header, you have now successfully
  compiled a concurrent program.
* Whether it works or not, as usual, is a different matter entirely.

== 27.6 Summary

* We have introduced the basics of the pthread library, including thread
  creation, building mutual exclusion via locks, and signaling and waiting via
  condition variables.
* You don't need much else to write robust and efficient multi-threaded code,
  except patience and a great deal of care!

'''

* We now end the chapter with a set of tips that might be useful to you when
  you write multi-threaded code (see the aside on the following page for
  details).
* There are other aspects of the API that are interesting; if you want more
  information, type `man -k pthread` on a Linux system to see over one hundred
  APIs that make up the entire interface.
* However, the basics discussed herein should enable you to build
  sophisticated (and hopefully, correct and performant) multi-threaded
  programs.
* The hard part with threads is not the APIs, but rather the tricky logic of
  how you build concurrent programs.
* Read on to learn more.

.Aside: Thread api guidelines
****
* There are a number of small but important things to remember when you use
  the POSIX thread library (or really, any thread library) to build a
  multi-threaded program.
* They are:

'''

.Keep it simple.
* Above all else, any code to lock or signal between threads should be as
  simple as possible.
* Tricky thread interactions lead to bugs.

.Minimize thread interactions.
* Try to keep the number of ways in which threads interact to a minimum.
* Each interaction should be carefully thought out and constructed with tried
  and true approaches (many of which we will learn about in the coming
  chapters).

.Initialize locks and condition variables.
* Failure to do so will lead to code that sometimes works and sometimes fails
  in very strange ways.

.Check your return codes.
* Of course, in any C and UNIX programming you do, you should be checking each
  and every return code, and it's true here as well.
* Failure to do so will lead to bizarre and hard to understand behavior,
  making you likely to (a) scream, (b) pull some of your hair out, or (c)
  both.

.Be careful with how you pass arguments to, and return values from, threads.
* In particular, any time you are passing a reference to a variable allocated
  on the stack, you are probably doing something wrong.

.Each thread has its own stack.
* As related to the point above, please remember that each thread has its own
  stack.
* Thus, if you have a locally-allocated variable inside of some function a
  thread is executing, it is essentially private to that thread; no other
  thread can (easily) access it.
* To share data between threads, the values must be in the heap or otherwise
  some locale that is globally accessible.

.Always use condition variables to signal between threads.
* While it is often tempting to use a simple flag, don't do it.

.Use the manual pages.
* On Linux, in particular, the pthread man pages are highly informative and
  discuss many of the nuances presented here, often in even more detail.
* Read them carefully!
****

== References

[B89] "An Introduction to Programming with Threads" by Andrew D. Birrell. DEC Technical Report, January, 1989. Available: https://birrell.org/andrew/papers/035-Threads.pdf::
* A classic but older introduction to threaded programming.
* Still a worthwhile read, and freely available.

[B97] "Programming with POSIX Threads" by David R. Butenhof. Addison-Wesley, May 1997.::
* Another one of these books on threads.

[B+96] "PThreads Programming: by A POSIX Standard for Better Multiprocessing.  " Dick Buttlar, Jacqueline Farrell, Bradford Nichols. O'Reilly, September 1996::
* A reasonable book from the excellent, practical publishing house O'Reilly.
* Our bookshelves certainly contain a great deal of books from this company,
  including some excellent offerings on Perl, Python, and Javascript
  (particularly Crockford's "Javascript: The Good Parts".)

[K+96] "Programming With Threads" by Steve Kleiman, Devang Shah, Bart Smaalders. Prentice Hall, January 1996.::
* Probably one of the better books in this space.
* Get it at your local library.
* Or steal it from your mother.
* More seriously, just ask your mother for it -- she'll let you borrow it,
  don't worry.

[X+10] "Ad Hoc Synchronization Considered Harmful" by Weiwei Xiong, Soyeon Park, Jiaqi Zhang, Yuanyuan Zhou, Zhiqiang Ma. OSDI 2010, Vancouver, Canada.::
* This paper shows how seemingly simple synchronization code can lead to a
  surprising number of bugs.
* Use condition variables and do the signaling correctly!

== Homework (Code)

* In this section, we'll write some simple multi-threaded programs and use a
  specific tool, called *helgrind*, to find problems in these programs.
* Read the README in the homework download for details on how to build the
  programs and run `helgrind`.

=== Overview

* In this homework, you'll use a real tool on Linux to find problems in
  multi-threaded code.
* The tool is called `helgrind` (available as part of the valgrind suite of
  debugging tools).

'''

* See http://valgrind.org/docs/manual/hg-manual.htm for details about the
  tool, including how to download and install it (if it's not already on your
  Linux system).

'''

* You'll then look at a number of multi-threaded C programs to see how you can
  use the tool to debug problematic threaded code.

* First things first: download and install valgrind and the related helgrind
  tool.

* Then, type `make` to build all the different programs.
* Examine the Makefile for more details on how that works.

'''

* Then, you have a few different C programs to look at:
** `main-race.c`: A simple race condition
** `main-deadlock.c`: A simple deadlock
** `main-deadlock-global.c`: A solution to the deadlock problem
** `main-signal.c`: A simple child/parent signaling example
** `main-signal-cv.c`: A more efficient signaling via condition variables
** `common_threads.h`: Header file with wrappers to make code check errors and
   be more readable

* With these programs, you can now answer the questions in the textbook.

=== Questions
:example-caption:

.{empty}
====
* First build `main-race.c`.
* Examine the code so you can see the (hopefully obvious) data race in the
  code.
* Now run `helgrind` (by typing `valgrind --tool=helgrind main-race`) to see
  how it reports the race.
* Does it point to the right lines of code?
* What other information does it give to you?
====

....
==2799883== Helgrind, a thread error detector
==2799883== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2799883== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2799883== Command: ./main-race
==2799883== 
==2799883== ---Thread-Announcement------------------------------------------
==2799883== 
==2799883== Thread #1 is the program's root thread
==2799883== 
==2799883== ---Thread-Announcement------------------------------------------
==2799883== 
==2799883== Thread #2 was created
==2799883==    at 0x499D9F3: clone (clone.S:76)
==2799883==    by 0x499E8EE: __clone_internal (clone-internal.c:83)
==2799883==    by 0x490C6D8: create_thread (pthread_create.c:295)
==2799883==    by 0x490D1FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==2799883==    by 0x4853767: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2799883==    by 0x109209: main (main-race.c:14)
==2799883== 
==2799883== ----------------------------------------------------------------
==2799883== 
==2799883== Possible data race during read of size 4 at 0x10C014 by thread #1
==2799883== Locks held: none
==2799883==    at 0x10922D: main (main-race.c:15)
==2799883== 
==2799883== This conflicts with a previous write of size 4 by thread #2
==2799883== Locks held: none
==2799883==    at 0x1091BE: worker (main-race.c:8)
==2799883==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2799883==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2799883==    by 0x499DA03: clone (clone.S:100)
==2799883==  Address 0x10c014 is 0 bytes inside data symbol "balance"
==2799883== 
==2799883== ----------------------------------------------------------------
==2799883== 
==2799883== Possible data race during write of size 4 at 0x10C014 by thread #1
==2799883== Locks held: none
==2799883==    at 0x109236: main (main-race.c:15)
==2799883== 
==2799883== This conflicts with a previous write of size 4 by thread #2
==2799883== Locks held: none
==2799883==    at 0x1091BE: worker (main-race.c:8)
==2799883==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2799883==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2799883==    by 0x499DA03: clone (clone.S:100)
==2799883==  Address 0x10c014 is 0 bytes inside data symbol "balance"
==2799883== 
==2799883== 
==2799883== Use --history-level=approx or =none to gain increased speed, at
==2799883== the cost of reduced accuracy of conflicting-access information
==2799883== For lists of detected and suppressed errors, rerun with: -s
==2799883== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
....

.{empty}
====
* What happens when you remove one of the offending lines of code?
* Now add a lock around one of the updates to the shared variable, and then
  around both.
* What does `helgrind` report in each of these cases?
====

* Removing one of the offending lines of code:

....
==2800305== Helgrind, a thread error detector
==2800305== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2800305== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2800305== Command: ./main-race
==2800305== 
==2800305== 
==2800305== Use --history-level=approx or =none to gain increased speed, at
==2800305== the cost of reduced accuracy of conflicting-access information
==2800305== For lists of detected and suppressed errors, rerun with: -s
==2800305== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
....

* Adding a lock around one of the updates to the shared variable:

....
==2800696== Helgrind, a thread error detector
==2800696== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2800696== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2800696== Command: ./main-race
==2800696== 
==2800696== ---Thread-Announcement------------------------------------------
==2800696== 
==2800696== Thread #1 is the program's root thread
==2800696== 
==2800696== ---Thread-Announcement------------------------------------------
==2800696== 
==2800696== Thread #2 was created
==2800696==    at 0x499D9F3: clone (clone.S:76)
==2800696==    by 0x499E8EE: __clone_internal (clone-internal.c:83)
==2800696==    by 0x490C6D8: create_thread (pthread_create.c:295)
==2800696==    by 0x490D1FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==2800696==    by 0x4853767: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800696==    by 0x109249: main (main-race.c:15)
==2800696== 
==2800696== ----------------------------------------------------------------
==2800696== 
==2800696==  Lock at 0x10C060 was first observed
==2800696==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800696==    by 0x109278: main (main-race.c:16)
==2800696==  Address 0x10c060 is 0 bytes inside data symbol "lock"
==2800696== 
==2800696== Possible data race during read of size 4 at 0x10C040 by thread #1
==2800696== Locks held: 1, at address 0x10C060
==2800696==    at 0x10929C: main (main-race.c:17)
==2800696== 
==2800696== This conflicts with a previous write of size 4 by thread #2
==2800696== Locks held: none
==2800696==    at 0x1091FE: worker (main-race.c:9)
==2800696==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800696==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2800696==    by 0x499DA03: clone (clone.S:100)
==2800696==  Address 0x10c040 is 0 bytes inside data symbol "balance"
==2800696== 
==2800696== ----------------------------------------------------------------
==2800696== 
==2800696==  Lock at 0x10C060 was first observed
==2800696==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800696==    by 0x109278: main (main-race.c:16)
==2800696==  Address 0x10c060 is 0 bytes inside data symbol "lock"
==2800696== 
==2800696== Possible data race during write of size 4 at 0x10C040 by thread #1
==2800696== Locks held: 1, at address 0x10C060
==2800696==    at 0x1092A5: main (main-race.c:17)
==2800696== 
==2800696== This conflicts with a previous write of size 4 by thread #2
==2800696== Locks held: none
==2800696==    at 0x1091FE: worker (main-race.c:9)
==2800696==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800696==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2800696==    by 0x499DA03: clone (clone.S:100)
==2800696==  Address 0x10c040 is 0 bytes inside data symbol "balance"
==2800696== 
==2800696== 
==2800696== Use --history-level=approx or =none to gain increased speed, at
==2800696== the cost of reduced accuracy of conflicting-access information
==2800696== For lists of detected and suppressed errors, rerun with: -s
==2800696== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
....

....
==2800865== Helgrind, a thread error detector
==2800865== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2800865== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2800865== Command: ./main-race
==2800865== 
==2800865== ---Thread-Announcement------------------------------------------
==2800865== 
==2800865== Thread #1 is the program's root thread
==2800865== 
==2800865== ---Thread-Announcement------------------------------------------
==2800865== 
==2800865== Thread #2 was created
==2800865==    at 0x499D9F3: clone (clone.S:76)
==2800865==    by 0x499E8EE: __clone_internal (clone-internal.c:83)
==2800865==    by 0x490C6D8: create_thread (pthread_create.c:295)
==2800865==    by 0x490D1FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==2800865==    by 0x4853767: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800865==    by 0x1092AB: main (main-race.c:17)
==2800865== 
==2800865== ----------------------------------------------------------------
==2800865== 
==2800865==  Lock at 0x10C060 was first observed
==2800865==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800865==    by 0x109204: worker (main-race.c:9)
==2800865==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800865==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2800865==    by 0x499DA03: clone (clone.S:100)
==2800865==  Address 0x10c060 is 0 bytes inside data symbol "lock"
==2800865== 
==2800865== Possible data race during read of size 4 at 0x10C040 by thread #1
==2800865== Locks held: none
==2800865==    at 0x1092CF: main (main-race.c:18)
==2800865== 
==2800865== This conflicts with a previous write of size 4 by thread #2
==2800865== Locks held: 1, at address 0x10C060
==2800865==    at 0x109231: worker (main-race.c:10)
==2800865==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800865==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2800865==    by 0x499DA03: clone (clone.S:100)
==2800865==  Address 0x10c040 is 0 bytes inside data symbol "balance"
==2800865== 
==2800865== ----------------------------------------------------------------
==2800865== 
==2800865==  Lock at 0x10C060 was first observed
==2800865==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800865==    by 0x109204: worker (main-race.c:9)
==2800865==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800865==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2800865==    by 0x499DA03: clone (clone.S:100)
==2800865==  Address 0x10c060 is 0 bytes inside data symbol "lock"
==2800865== 
==2800865== Possible data race during write of size 4 at 0x10C040 by thread #1
==2800865== Locks held: none
==2800865==    at 0x1092D8: main (main-race.c:18)
==2800865== 
==2800865== This conflicts with a previous write of size 4 by thread #2
==2800865== Locks held: 1, at address 0x10C060
==2800865==    at 0x109231: worker (main-race.c:10)
==2800865==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2800865==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2800865==    by 0x499DA03: clone (clone.S:100)
==2800865==  Address 0x10c040 is 0 bytes inside data symbol "balance"
==2800865== 
==2800865== 
==2800865== Use --history-level=approx or =none to gain increased speed, at
==2800865== the cost of reduced accuracy of conflicting-access information
==2800865== For lists of detected and suppressed errors, rerun with: -s
==2800865== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
....

* Adding a lock around both the updates to the shared variable:

....
==2800989== Helgrind, a thread error detector
==2800989== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2800989== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2800989== Command: ./main-race
==2800989== 
==2800989== 
==2800989== Use --history-level=approx or =none to gain increased speed, at
==2800989== the cost of reduced accuracy of conflicting-access information
==2800989== For lists of detected and suppressed errors, rerun with: -s
==2800989== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 7 from 7)
....

.{empty}
====
* Now let's look at `main-deadlock.c`.
* Examine the code.
* This code has a problem known as *deadlock* (which we discuss in much more
  depth in a forthcoming chapter).
* Can you see what problem it might have?
====

.{empty}
====
* Now run `helgrind` on this code.
* What does `helgrind` report?
====

....
==2801217== Helgrind, a thread error detector
==2801217== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2801217== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2801217== Command: ./main-deadlock
==2801217== 
==2801217== ---Thread-Announcement------------------------------------------
==2801217== 
==2801217== Thread #3 was created
==2801217==    at 0x499D9F3: clone (clone.S:76)
==2801217==    by 0x499E8EE: __clone_internal (clone-internal.c:83)
==2801217==    by 0x490C6D8: create_thread (pthread_create.c:295)
==2801217==    by 0x490D1FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==2801217==    by 0x4853767: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x10939F: main (main-deadlock.c:24)
==2801217== 
==2801217== ----------------------------------------------------------------
==2801217== 
==2801217== Thread #3: lock order "0x10C040 before 0x10C080" violated
==2801217== 
==2801217== Observed (incorrect) order is: acquisition of lock at 0x10C080
==2801217==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x109269: worker (main-deadlock.c:13)
==2801217==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801217==    by 0x499DA03: clone (clone.S:100)
==2801217== 
==2801217==  followed by a later acquisition of lock at 0x10C040
==2801217==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x109298: worker (main-deadlock.c:14)
==2801217==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801217==    by 0x499DA03: clone (clone.S:100)
==2801217== 
==2801217== Required order was established by acquisition of lock at 0x10C040
==2801217==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x10920B: worker (main-deadlock.c:10)
==2801217==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801217==    by 0x499DA03: clone (clone.S:100)
==2801217== 
==2801217==  followed by a later acquisition of lock at 0x10C080
==2801217==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x10923A: worker (main-deadlock.c:11)
==2801217==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801217==    by 0x499DA03: clone (clone.S:100)
==2801217== 
==2801217==  Lock at 0x10C040 was first observed
==2801217==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x10920B: worker (main-deadlock.c:10)
==2801217==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801217==    by 0x499DA03: clone (clone.S:100)
==2801217==  Address 0x10c040 is 0 bytes inside data symbol "m1"
==2801217== 
==2801217==  Lock at 0x10C080 was first observed
==2801217==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x10923A: worker (main-deadlock.c:11)
==2801217==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801217==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801217==    by 0x499DA03: clone (clone.S:100)
==2801217==  Address 0x10c080 is 0 bytes inside data symbol "m2"
==2801217== 
==2801217== 
==2801217== 
==2801217== Use --history-level=approx or =none to gain increased speed, at
==2801217== the cost of reduced accuracy of conflicting-access information
==2801217== For lists of detected and suppressed errors, rerun with: -s
==2801217== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 7 from 7)
....

.{empty}
====
* Now run `helgrind` on `main-deadlock-global.c`.
* Examine the code; does it have the same problem that `main-deadlock.c` has?
* Should `helgrind` be reporting the same error?
* What does this tell you about tools like `helgrind`?
====

....
==2801298== Helgrind, a thread error detector
==2801298== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2801298== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2801298== Command: ./main-deadlock-global
==2801298== 
==2801298== ---Thread-Announcement------------------------------------------
==2801298== 
==2801298== Thread #3 was created
==2801298==    at 0x499D9F3: clone (clone.S:76)
==2801298==    by 0x499E8EE: __clone_internal (clone-internal.c:83)
==2801298==    by 0x490C6D8: create_thread (pthread_create.c:295)
==2801298==    by 0x490D1FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==2801298==    by 0x4853767: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x1093FD: main (main-deadlock-global.c:27)
==2801298== 
==2801298== ----------------------------------------------------------------
==2801298== 
==2801298== Thread #3: lock order "0x10C080 before 0x10C0C0" violated
==2801298== 
==2801298== Observed (incorrect) order is: acquisition of lock at 0x10C0C0
==2801298==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x109298: worker (main-deadlock-global.c:15)
==2801298==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801298==    by 0x499DA03: clone (clone.S:100)
==2801298== 
==2801298==  followed by a later acquisition of lock at 0x10C080
==2801298==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x1092C7: worker (main-deadlock-global.c:16)
==2801298==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801298==    by 0x499DA03: clone (clone.S:100)
==2801298== 
==2801298== Required order was established by acquisition of lock at 0x10C080
==2801298==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x10923A: worker (main-deadlock-global.c:12)
==2801298==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801298==    by 0x499DA03: clone (clone.S:100)
==2801298== 
==2801298==  followed by a later acquisition of lock at 0x10C0C0
==2801298==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x109269: worker (main-deadlock-global.c:13)
==2801298==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801298==    by 0x499DA03: clone (clone.S:100)
==2801298== 
==2801298==  Lock at 0x10C080 was first observed
==2801298==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x10923A: worker (main-deadlock-global.c:12)
==2801298==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801298==    by 0x499DA03: clone (clone.S:100)
==2801298==  Address 0x10c080 is 0 bytes inside data symbol "m1"
==2801298== 
==2801298==  Lock at 0x10C0C0 was first observed
==2801298==    at 0x4850CCF: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x109269: worker (main-deadlock-global.c:13)
==2801298==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801298==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801298==    by 0x499DA03: clone (clone.S:100)
==2801298==  Address 0x10c0c0 is 0 bytes inside data symbol "m2"
==2801298== 
==2801298== 
==2801298== 
==2801298== Use --history-level=approx or =none to gain increased speed, at
==2801298== the cost of reduced accuracy of conflicting-access information
==2801298== For lists of detected and suppressed errors, rerun with: -s
==2801298== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 7 from 7)
....

.{empty}
====
* Let's next look at `main-signal.c`.
* This code uses a variable (`done`) to signal that the child is done and that
  the parent can now continue.
* Why is this code inefficient?
* (what does the parent end up spending its time doing, particularly if the
  child thread takes a long time to complete?)
====

* Spinning for a long time just wastes CPU cycles

.{empty}
====
* Now run `helgrind` on this program.
* What does it report?
* Is the code correct?
====

....
==2801757== Helgrind, a thread error detector
==2801757== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2801757== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2801757== Command: ./main-signal
==2801757== 
==2801757== ---Thread-Announcement------------------------------------------
==2801757== 
==2801757== Thread #1 is the program's root thread
==2801757== 
==2801757== ---Thread-Announcement------------------------------------------
==2801757== 
==2801757== Thread #2 was created
==2801757==    at 0x499D9F3: clone (clone.S:76)
==2801757==    by 0x499E8EE: __clone_internal (clone-internal.c:83)
==2801757==    by 0x490C6D8: create_thread (pthread_create.c:295)
==2801757==    by 0x490D1FF: pthread_create@@GLIBC_2.34 (pthread_create.c:828)
==2801757==    by 0x4853767: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801757==    by 0x109214: main (main-signal.c:15)
==2801757== 
==2801757== ----------------------------------------------------------------
==2801757== 
==2801757== Possible data race during read of size 4 at 0x10C014 by thread #1
==2801757== Locks held: none
==2801757==    at 0x109239: main (main-signal.c:16)
==2801757== 
==2801757== This conflicts with a previous write of size 4 by thread #2
==2801757== Locks held: none
==2801757==    at 0x1091C5: worker (main-signal.c:9)
==2801757==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801757==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801757==    by 0x499DA03: clone (clone.S:100)
==2801757==  Address 0x10c014 is 0 bytes inside data symbol "done"
==2801757== 
==2801757== ----------------------------------------------------------------
==2801757== 
==2801757== Possible data race during write of size 1 at 0x52A51BD by thread #1
==2801757== Locks held: none
==2801757==    at 0x4859796: mempcpy (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801757==    by 0x4903664: _IO_new_file_xsputn (fileops.c:1235)
==2801757==    by 0x4903664: _IO_file_xsputn@@GLIBC_2.2.5 (fileops.c:1196)
==2801757==    by 0x48F8F1B: puts (ioputs.c:40)
==2801757==    by 0x10924E: main (main-signal.c:18)
==2801757==  Address 0x52a51bd is 45 bytes inside a block of size 4,096 alloc'd
==2801757==    at 0x484A919: malloc (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801757==    by 0x48F6BA3: _IO_file_doallocate (filedoalloc.c:101)
==2801757==    by 0x4905CDF: _IO_doallocbuf (genops.c:347)
==2801757==    by 0x4904F5F: _IO_file_overflow@@GLIBC_2.2.5 (fileops.c:744)
==2801757==    by 0x49036D4: _IO_new_file_xsputn (fileops.c:1243)
==2801757==    by 0x49036D4: _IO_file_xsputn@@GLIBC_2.2.5 (fileops.c:1196)
==2801757==    by 0x48F8F1B: puts (ioputs.c:40)
==2801757==    by 0x1091C4: worker (main-signal.c:8)
==2801757==    by 0x485396A: ??? (in /usr/libexec/valgrind/vgpreload_helgrind-amd64-linux.so)
==2801757==    by 0x490CAC2: start_thread (pthread_create.c:442)
==2801757==    by 0x499DA03: clone (clone.S:100)
==2801757==  Block was alloc'd by thread #2
==2801757== 
this should print first
this should print last
==2801757== 
==2801757== Use --history-level=approx or =none to gain increased speed, at
==2801757== the cost of reduced accuracy of conflicting-access information
==2801757== For lists of detected and suppressed errors, rerun with: -s
==2801757== ERROR SUMMARY: 23 errors from 2 contexts (suppressed: 77 from 28)
....

.{empty}
====
* Now look at a slightly modified version of the code, which is found in
  `main-signal-cv.c`.
* This version uses a condition variable to do the signaling (and associated
  lock).
* Why is this code preferred to the previous version?
* Is it correctness, or performance, or both?
====

* Both

.{empty}
====
* Once again run helgrind on `main-signal-cv`.
* Does it report any errors?
====

....
==2802648== Helgrind, a thread error detector
==2802648== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==2802648== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==2802648== Command: ./main-signal-cv
==2802648== 
this should print first
this should print last
==2802648== 
==2802648== Use --history-level=approx or =none to gain increased speed, at
==2802648== the cost of reduced accuracy of conflicting-access information
==2802648== For lists of detected and suppressed errors, rerun with: -s
==2802648== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 7 from 7)
....
