= 5 Interlude: Process API
:figure-caption: Figure 5.
:source-highlighter: rouge
:tabsize: 8
:toc: left

.Aside: Interludes
****
* Interludes will cover more practical aspects of systems, including a
  particular focus on operating system APIs and how to use them.
* If you don't like practical things, you could skip these interludes.
* But you should like practical things, because, well, they are generally
  useful in real life; companies, for example, don't usually hire you for your
  non-practical skills.
****

* In this interlude, we discuss process creation in UNIX systems.
* UNIX presents one of the most intriguing ways to create a new process with a
  pair of system calls: `fork()` and `exec()`.
* A third routine, `wait()`, can be used by a process wishing to wait for a
  process it has created to complete.
* We now present these interfaces in more detail, with a few simple examples
  to motivate us.
* And thus, our problem:

.Crux: How to create and control processes
****
* What interfaces should the OS present for process creation and control?
* How should these interfaces be designed to enable powerful functionality,
  ease of use, and high performance?
****

== 5.1 The `fork()` System Call

* The `fork()` system call is used to create a new process [C63].
* However, be forewarned: it is certainly the strangest routine you will ever
  call{empty}footnote:[Well, OK, we admit that we don't know that for sure;
  who knows what routines you call when no one is looking? But `fork()` is
  pretty odd, no matter how unusual your routine-calling patterns are.].
* More specifically, you have a running program whose code looks like what you
  see in Figure 5.1; examine the code, or better yet, type it in and run it
  yourself!

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. Calling `fork()` (`p1.c`)
[,c]
----
include::p1.c[]
----

* When you run this program (called `p1.c`), you'll see the following:
+
....
prompt> ./p1
hello (pid:29146)
parent of 29147 (pid:29146)
child (pid:29147)
prompt>
....

* Let us understand what happened in more detail in `p1.c`.
* When it first started running, the process prints out a hello message;
  included in that message is its *process identifier*, also known as a *PID*.
* The process has a PID of 29146; in UNIX systems, the PID is used to name the
  process if one wants to do something with the process, such as (for example)
  stop it from running.
* So far, so good.

'''

* Now the interesting part begins.
* The process calls the `fork()` system call, which the OS provides as a way
  to create a new process.
* The odd part: the process that is created is an (almost) _exact copy of the
  calling process_.
* That means that to the OS, it now looks like there are two copies of the
  program `p1` running, and both are about to return from the `fork()` system
  call.
* The newly-created process (called the *child*, in contrast to the creating
  *parent*) doesn't start running at `main()`, like you might expect (note,
  the "hello" message only got printed out once); rather, it just comes into
  life as if it had called `fork()` itself.

'''

* You might have noticed: the child isn't an _exact_ copy.
* Specifically, although it now has its own copy of the address space (i.e.,
  its own private memory), its own registers, its own PC, and so forth, the
  value it returns to the caller of *fork()* is different.
* Specifically, while the parent receives the PID of the newly-created child,
  the child receives a return code of zero.
* This differentiation is useful, because it is simple then to write the code
  that handles the two different cases (as above).

'''

* You might also have noticed: the output (of `p1.c`) is not deterministic.
* When the child process is created, there are now two active processes in the
  system that we care about: the parent and the child.
* Assuming we are running on a system with a single CPU (for simplicity), then
  either the child or the parent might run at that point.
* In our example (above), the parent did and thus printed out its message first.
* In other cases, the opposite might happen, as we show in this output trace:
+
....
prompt> ./p1
hello (pid:29146)
child (pid:29147)
parent of 29147 (pid:29146)
prompt>
....

'''

* The CPU *scheduler*, a topic we'll discuss in great detail soon, determines
  which process runs at a given moment in time; because the scheduler is
  complex, we cannot usually make strong assumptions about what it will choose
  to do, and hence which process will run first.
* This *non-determinism*, as it turns out, leads to some interesting problems,
  particularly in *multi-threaded programs*; hence, we'll see a lot more
  non-determinism when we study *concurrency* in the second part of the book.
