= 5 Interlude: Process API
:figure-caption: Figure 5.
:source-highlighter: rouge
:tabsize: 8
:toc: left

.Aside: Interludes
****
* Interludes will cover more practical aspects of systems, including a
  particular focus on operating system APIs and how to use them.
* If you don't like practical things, you could skip these interludes.
* But you should like practical things, because, well, they are generally
  useful in real life; companies, for example, don't usually hire you for your
  non-practical skills.
****

* In this interlude, we discuss process creation in UNIX systems.
* UNIX presents one of the most intriguing ways to create a new process with a
  pair of system calls: `fork()` and `exec()`.
* A third routine, `wait()`, can be used by a process wishing to wait for a
  process it has created to complete.
* We now present these interfaces in more detail, with a few simple examples
  to motivate us.
* And thus, our problem:

.Crux: How to create and control processes
****
* What interfaces should the OS present for process creation and control?
* How should these interfaces be designed to enable powerful functionality,
  ease of use, and high performance?
****

== 5.1 The `fork()` System Call

* The `fork()` system call is used to create a new process [C63].
* However, be forewarned: it is certainly the strangest routine you will ever
  call{empty}footnote:[Well, OK, we admit that we don't know that for sure;
  who knows what routines you call when no one is looking? But `fork()` is
  pretty odd, no matter how unusual your routine-calling patterns are.].
* More specifically, you have a running program whose code looks like what you
  see in Figure 5.1; examine the code, or better yet, type it in and run it
  yourself!

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. Calling `fork()` (`p1.c`)
[,c]
----
include::p1.c[]
----

* When you run this program (called `p1.c`), you'll see the following:
+
....
prompt> ./p1
hello (pid:29146)
parent of 29147 (pid:29146)
child (pid:29147)
prompt>
....

* Let us understand what happened in more detail in `p1.c`.
* When it first started running, the process prints out a hello message;
  included in that message is its *process identifier*, also known as a *PID*.
* The process has a PID of 29146; in UNIX systems, the PID is used to name the
  process if one wants to do something with the process, such as (for example)
  stop it from running.
* So far, so good.

'''

* Now the interesting part begins.
* The process calls the `fork()` system call, which the OS provides as a way
  to create a new process.
* The odd part: the process that is created is an (almost) _exact copy of the
  calling process_.
* That means that to the OS, it now looks like there are two copies of the
  program `p1` running, and both are about to return from the `fork()` system
  call.
* The newly-created process (called the *child*, in contrast to the creating
  *parent*) doesn't start running at `main()`, like you might expect (note,
  the "hello" message only got printed out once); rather, it just comes into
  life as if it had called `fork()` itself.

'''

* You might have noticed: the child isn't an _exact_ copy.
* Specifically, although it now has its own copy of the address space (i.e.,
  its own private memory), its own registers, its own PC, and so forth, the
  value it returns to the caller of *fork()* is different.
* Specifically, while the parent receives the PID of the newly-created child,
  the child receives a return code of zero.
* This differentiation is useful, because it is simple then to write the code
  that handles the two different cases (as above).

'''

* You might also have noticed: the output (of `p1.c`) is not deterministic.
* When the child process is created, there are now two active processes in the
  system that we care about: the parent and the child.
* Assuming we are running on a system with a single CPU (for simplicity), then
  either the child or the parent might run at that point.
* In our example (above), the parent did and thus printed out its message first.
* In other cases, the opposite might happen, as we show in this output trace:
+
....
prompt> ./p1
hello (pid:29146)
child (pid:29147)
parent of 29147 (pid:29146)
prompt>
....

'''

* The CPU *scheduler*, a topic we'll discuss in great detail soon, determines
  which process runs at a given moment in time; because the scheduler is
  complex, we cannot usually make strong assumptions about what it will choose
  to do, and hence which process will run first.
* This *non-determinism*, as it turns out, leads to some interesting problems,
  particularly in *multi-threaded programs*; hence, we'll see a lot more
  non-determinism when we study *concurrency* in the second part of the book.

== 5.2 The `wait()` System Call

* So far, we haven't done much: just created a child that prints out a message
  and exits.
* Sometimes, as it turns out, it is quite useful for a parent to wait for a
  child process to finish what it has been doing.
* This task is accomplished with the `wait()` system call (or its more
  complete sibling `waitpid()`); see Figure 5.2 for details.

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. Calling `fork()` And `wait()` (`p2.c`)
[,c]
----
include::p2.c[]
----

* In this example (`p2.c`), the parent process calls `wait()` to delay its
  execution until the child finishes executing.
* When the child is done, `wait()` returns to the parent.

'''

* Adding a `wait()` call to the code above makes the output deterministic.
* Can you see why?
* Go ahead, think about it.
* (waiting for you to think .... and done)
* Now that you have thought a bit, here is the output:
+
....
prompt> ./p2
hello (pid:29266)
child (pid:29267)
parent of 29267 (rc_wait:29267) (pid:29266)
prompt>
....

* With this code, we now know that the child will always print first.
* Why do we know that?
* Well, it might simply run first, as before, and thus print before the
  parent.
* However, if the parent does happen to run first, it will immediately call
  `wait()`; this system call won't return until the child has run and
  exited{empty}footnote:[There are a few cases where `wait()` returns before
  the child exits; read the man page for more details, as always. And beware
  of any absolute and unqualified statements this book makes, such as "the
  child will always print first" or "UNIX is the best thing in the world, even
  better than ice cream."].
* Thus, even when the parent runs first, it politely waits for the child to
  finish running, then `wait()` returns, and then the parent prints its
  message.

== 5.3 Finally, The `exec()` System Call

* A final and important piece of the process creation API is the `exec()`
  system call{empty}footnote:[On Linux, there are six variants of `exec()`:
  `execl()`, `execlp()`, `execle()`, `execv()`, `execvp()`, and `execvpe()`.
  Read the man pages to learn more.].
* This system call is useful when you want to run a program that is different
  from the calling program.
* For example, calling `fork()` in `p2.cx is only useful if you want to keep
  running copies of the same program.
* However, often you want to run a different program; `exec()` does just that
  (Figure 5.3).

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. Calling `fork()`, `wait()`, And `exec()` (`p3.c`)
[,c]
----
include::p3.c[]
----

* In this example, the child process calls `execvp()` in order to run the
  program `wc`, which is the word counting program.
* In fact, it runs `wc` on the source file `p3.c`, thus telling us how many
  lines, words, and bytes are found in the file:
+
....
prompt> ./p3
hello (pid:29383)
child (pid:29384)
29 107 1030 p3.c
parent of 29384 (rc_wait:29384) (pid:29383)
prompt>
....

'''

* The `fork()` system call is strange; its partner in crime, `exec()`, is not
  so normal either.
* What it does: given the name of an executable (e.g., `wc`), and some
  arguments (e.g., `p3.c`), it loads code (and static data) from that
  executable and overwrites its current code segment (and current static data)
  with it; the heap and stack and other parts of the memory space of the
  program are re-initialized.
* Then the OS simply runs that program, passing in any arguments as the
  `argv` of that process.
* Thus, it does not create a new process; rather, it transforms the currently
  running program (formerly `p3`) into a different running program (`wc`).
* After the `exec()` in the child, it is almost as if `p3.c` never ran; a
  successful call to `exec()` never returns.

.Tip: Getting it right (Lampson's law)
****
* As Lampson states in his well-regarded "Hints for Computer Systems Design"
  [L83], "*Get it right*. Neither abstraction nor simplicity is a substitute for
  getting it right."
* Sometimes, you just have to do the right thing, and when you do, it is way
  better than the alternatives.
* There are lots of ways to design APIs for process creation; however, the
  combination of `fork()` and `exec()` are simple and immensely powerful.
* Here, the UNIX designers simply got it right.
* And because Lampson so often "got it right", we name the law in his honor.
****

== 5.4 Why? Motivating The API

* Of course, one big question you might have: why would we build such an odd
  interface to what should be the simple act of creating a new process?
* Well, as it turns out, the separation of `fork()` and `exec()` is essential
  in building a UNIX shell, because it lets the shell run code after the call
  to `fork()` but _before_ the call to `exec()`; this code can alter the
  environment of the about-to-be-run program, and thus enables a variety of
  interesting features to be readily built.

'''

* The shell is just a user program{empty}footnote:[And there are lots of
  shells; `tcsh`, `bash`, and `zsh` to name a few. You should pick one, read
  its man pages, and learn more about it; all UNIX experts do.].
* It shows you a *prompt* and then waits for you to type something into it.
* You then type a command (i.e., the name of an executable program, plus any
  arguments) into it; in most cases, the shell then figures out where in the
  file system the executable resides, calls `fork()` to create a new child
  process to run the command, calls some variant of `exec()` to run the
  command, and then waits for the command to complete by calling `wait()`.
* When the child completes, the shell returns from `wait()` and prints out a
  prompt again, ready for your next command.

'''

* The separation of `fork()` and `exec()` allows the shell to do a whole bunch
  of useful things rather easily.
* For example:
+
....
prompt> wc p3.c > newfile.txt
....

'''

* In the example above, the output of the program `wc` is *redirected* into the
  output file `newfile.txt` (the greater-than sign is how said redirection is
  indicated).
* The way the shell accomplishes this task is quite simple: when the child is
  created, before calling `exec()`, the shell (specifically, the code executed
  in the child process) closes *standard output* and opens the file
  `newfile.txt`.
* By doing so, any output from the soon-to-be-running program `wc` is sent to
  the file instead of the screen (open file descriptors are kept open across
  the `exec()` call, thus enabling this behavior [SR05]).

'''

* Figure 5.4 (page 8) shows a program that does exactly this.
* The reason this redirection works is due to an assumption about how the
  operating system manages file descriptors.
* Specifically, UNIX systems start looking for free file descriptors at zero.
* In this case, STDOUT_FILENO will be the first available one and thus get
  assigned when `open()` is called.
* Subsequent writes by the child process to the standard output file
  descriptor, for example by routines such as `printf()`, will then be routed
  transparently to the newly-opened file instead of the screen.

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. All Of The Above With Redirection (`p4.c`)
[,c]
----
include::p4.c[]
----

* Here is the output of running the `p4.c` program:
+
....
prompt> ./p4
prompt> cat p4.output
32 109 846 p4.c
prompt>
....

'''

* You'll notice (at least) two interesting tidbits about this output.
* First, when `p4` is run, it looks as if nothing has happened; the shell just
  prints the command prompt and is immediately ready for your next command.
* However, that is not the case; the program `p4` did indeed call `fork()` to
  create a new child, and then run the `wc` program via a call to `execvp()`.
* You don't see any output printed to the screen because it has been
  redirected to the file `p4.output`.
* Second, you can see that when we cat the output file, all the expected
  output from running `wc` is found.
* Cool, right?

'''

* UNIX pipes are implemented in a similar way, but with the `pipe()` system
  call.
* In this case, the output of one process is connected to an in-kernel *pipe*
  (i.e., queue), and the input of another process is connected to that same
  pipe; thus, the output of one process seamlessly is used as input to the
  next, and long and useful chains of commands can be strung together.
* As a simple example, consider looking for a word in a file, and then
  counting how many times said word occurs; with pipes and the utilities
  `grep` and `wc`, it is easy; just type `grep -o foo file | wc -l` into the
  command prompt and marvel at the result.

'''

* Finally, while we just have sketched out the process API at a high level,
  there is a lot more detail about these calls out there to be learned and
  digested; we'll learn more, for example, about file descriptors when we talk
  about file systems in the third part of the book.
* For now, suffice it to say that the `fork()`/`exec()` combination is a
  powerful way to create and manipulate processes.

== 5.5 Process Control And Users

* Beyond `fork()`, `exec()`, and `wait()`, there are a lot of other interfaces
  for interacting with processes in UNIX systems.
* For example, the `kill()` system call is used to send *signals* to a
  process, including directives to pause, die, and other useful imperatives.
* For convenience, in most UNIX shells, certain keystroke combinations are
  configured to deliver a specific signal to the currently running process;
  for example, control-c sends a `SIGINT` (interrupt) to the process (normally
  terminating it) and control-z sends a `SIGTSTP` (stop) signal thus pausing
  the process in mid-execution (you can resume it later with a command, e.g.,
  the `fg` built-in command found in many shells).

'''

* The entire signals subsystem provides a rich infrastructure to deliver
  external events to processes, including ways to receive and process those
  signals within individual processes, and ways to send signals to individual
  processes as well as entire *process groups*.
* To use this form of communication, a process should use the `signal()`
  system call to "catch" various signals; doing so ensures that when a
  particular signal is delivered to a process, it will suspend its normal
  execution and run a particular piece of code in response to the signal.
* Read elsewhere [SR05] to learn more about signals and their many
  intricacies.

.Aside: RTFM -- Read the man pages
****
* Many times in this book, when referring to a particular system call or
  library call, we'll tell you to read the *manual pages*, or *man pages* for
  short.
* Man pages are the original form of documentation that exist on UNIX systems;
  realize that they were created before the thing called *the web* existed.

'''

* Spending some time reading man pages is a key step in the growth of a
  systems programmer; there are tons of useful tidbits hidden in those pages.
* Some particularly useful pages to read are the man pages for whichever shell
  you are using (e.g., *tcsh*, or *bash*), and certainly for any system calls
  your program makes (in order to see what return values and error conditions
  exist).

'''

* Finally, reading the man pages can save you some embarrassment.
* When you ask colleagues about some intricacy of `fork()`, they may simply
  reply: "RTFM." 
* This is your colleagues' way of gently urging you to Read The Man pages.
* The F in RTFM just adds a little color to the phrase...
****

* This naturally raises the question: who can send a signal to a process, and
  who cannot?
* Generally, the systems we use can have multiple people using them at the
  same time; if one of these people can arbitrarily send signals such as
  `SIGINT` (to interrupt a process, likely terminating it), the usability and
  security of the system will be compromised.
* As a result, modern systems include a strong conception of the notion of a
  *user*.
* The user, after entering a password to establish credentials, logs in to
  gain access to system resources.
* The user may then launch one or many processes, and exercise full control
  over them (pause them, kill them, etc.).
* Users generally can only control their own processes; it is the job of the
  operating system to parcel out resources (such as CPU, memory, and disk) to
  each user (and their processes) to meet overall system goals.

== References

[L83] "Hints for Computer Systems Design" by Butler Lampson. ACM Operating Systems Review, Volume 15:5, October 1983.::
* Lampson's famous hints on how to design computer systems.
* You should read it at some point in your life, and probably at many points
  in your life.

[SR05] "Advanced Programming in the UNIX Environment" by W. Richard Stevens, Stephen A. Rago. Addison-Wesley, 2005.::
* All nuances and subtleties of using UNIX APIs are found herein.
* Buy this book!
* Read it!
* And most importantly, *live it*.
