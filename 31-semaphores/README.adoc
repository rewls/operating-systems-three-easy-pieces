= 31 Semaphores
:figure-caption: Figure 31.
:imagesdir: ../images
:source-highlighter: rouge
:tabsize: 8
:toc: left

* As we know now, one needs both locks and condition variables to solve a
  broad range of relevant and interesting concurrency problems.
* One of the first people to realize this years ago was Edsger Dijkstra
  (though it is hard to know the exact history [GR92]), known among other
  things for his famous "shortest paths" algorithm in graph theory [D59], an
  early polemic on structured programming entitled "Goto Statements Considered
  Harmful" [D68a] (what a great title!), and, in the case we will study here,
  the introduction of a synchronization primitive called the semaphore [D68b,
  D72].
* Indeed, Dijkstra and colleagues invented the semaphore as a single primitive
  for all things related to synchronization; as you will see, one can use
  semaphores as both locks and condition variables.

.The crux: How to use semaphores
****
* How can we use semaphores instead of locks and condition variables?
* What is the definition of a semaphore?
* What is a binary semaphore?
* Is it straightforward to build a semaphore out of locks and condition
  variables?
* To build locks and condition variables out of semaphores?
****

== 31.1 Semaphores: A Definition

* A semaphore is an object with an integer value that we can manipulate with
  two routines; in the POSIX standard, these routines are `sem_wait()` and
  `sem_post()`{empty}footnote:[Historically, `sem_wait()` was called `P()` by
  Dijkstra and `sem_post()` called `V()`. These shortened forms come from
  Dutch words; interestingly, which Dutch words they supposedly derive from
  has changed over time. Originally, `P()` came from "passering" (to pass) and
  V() from "vrijgave" (release); later, Dijkstra wrote `P()` was from
  "prolaag", a contraction of "probeer" (Dutch for "try") and "verlaag"
  ("decrease"), and `V()` from "verhoog" which means "increase". Sometimes,
  people call them down and up. Use the Dutch versions to impress your
  friends, or confuse them, or both. See
  `https://news.ycombinator.com/item?id=8761539`) for details.].
* Because the initial value of the semaphore determines its behavior, before
  calling any other routine to interact with the semaphore, we must first
  initialize it to some value, as the code in Figure 31.1 does.

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. Initializing A Semaphore
[,c]
----
#include <semaphore.h>
sem_t s;
sem_init(&s, 0, 1);
----

* In the figure, we declare a semaphore `s` and initialize it to the value 1
  by passing 1 in as the third argument.
* The second argument to `sem_init()` will be set to 0 in all of the examples
  we'll see; this indicates that the semaphore is shared between threads in
  the same process.
* See the man page for details on other usages of semaphores (namely, how they
  can be used to synchronize access across different processes), which require
  a different value for that second argument.

'''

* After a semaphore is initialized, we can call one of two functions to
  interact with it, `sem_wait()` or `sem_post()`.
* The behavior of these two functions is seen in Figure 31.2.

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. Semaphore: Definitions Of Wait And Post
[,c]
----
int sem_wait(sem_t *s) {
	decrement the value of semaphore s by one
	wait if value of semaphore s is negative
}

int sem_post(sem_t *s) {
	increment the value of semaphore s by one
	if there are one or more threads waiting, wake one
}
----

* For now, we are not concerned with the implementation of these routines,
  which clearly requires some care; with multiple threads calling into
  `sem_wait()` and `sem_post()`, there is the obvious need for managing these
  critical sections.
* We will now focus on how to use these primitives; later we may discuss how
  they are built.

'''

* We should discuss a few salient aspects of the interfaces here.
* First, we can see that `sem_wait()` will either return right away (because
  the value of the semaphore was one or higher when we called `sem_wait()`),
  or it will cause the caller to suspend execution waiting for a subsequent
  post.
* Of course, multiple calling threads may call into `sem_wait()`, and thus all
  be queued waiting to be woken.

'''

* Second, we can see that `sem_post()` does not wait for some particular
  condition to hold like `sem_wait()` does.
* Rather, it simply increments the value of the semaphore and then, if there
  is a thread waiting to be woken, wakes one of them up.

'''

* Third, the value of the semaphore, when negative, is equal to the number of
  waiting threads [D68b].
* Though the value generally isn't seen by users of the semaphores, this
  invariant is worth knowing and perhaps can help you remember how a semaphore
  functions.

'''

* Don't worry (yet) about the seeming race conditions possible within the
  semaphore; assume that the actions they make are performed atomically.
* We will soon use locks and condition variables to do just this.

== 31.2 Binary Semaphores (Locks)

* We are now ready to use a semaphore.
* Our first use will be one with which we are already familiar: using a
  semaphore as a lock.
* See Figure 31.3 for a code snippet; therein, you'll see that we simply
  surround the critical section of interest with a `sem_wait()`/`sem_post()`
  pair.
* Critical to making this work, though, is the initial value of the semaphore
  `m` (initialized to `X` in the figure).
* What should `X` be?

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. A Binary Semaphore (That Is, A Lock)
[,c]
----
sem_t m;
sem_init(&m, 0, X); // init to X; what should X be?

sem_wait(&m);
// critical section here
sem_post(&m);
----

* ... _(Try thinking about it before going on)_ ...

'''

* Looking back at definition of the `sem_wait()` and `sem_post()` routines
  above, we can see that the initial value should be 1.

'''

* To make this clear, let's imagine a scenario with two threads.
* The first thread (Thread 0) calls `sem_wait()`; it will first decrement the
  value of the semaphore, changing it to 0.
* Then, it will wait only if the value is not greater than or equal to 0.
* Because the value is 0, `sem_wait()` will simply return and the calling
  thread will continue; Thread 0 is now free to enter the critical section.
* If no other thread tries to acquire the lock while Thread 0 is inside the
  critical section, when it calls `sem_post()`, it will simply restore the
  value of the semaphore to 1 (and not wake a waiting thread, because there
  are none).
* Figure 31.4 shows a trace of this scenario.

:figure-number: {counter:figure-number}
.{figure-caption} {figure-number}. Thread Trace: Single Thread Using A Semaphore
[%autowidth]
|===
|Value of Semaphore	|Thread 0		|Thread 1

|1			|			|
|1			|call `sem_wait()`	|
|0			|`sem_wait()` returns	|
|0			|(`crit sect`)		|
|0			|call `sem_post()`	|
|1			|`sem_post()` returns	|
|===

* A more interesting case arises when Thread 0 "holds the lock" (i.e., it has
  called `sem_wait()` but not yet called `sem_post()`), and another thread
  (Thread 1) tries to enter the critical section by calling `sem_wait()`.
* In this case, Thread 1 will decrement the value of the semaphore to -1, and
  thus wait (putting itself to sleep and relinquishing the processor).
* When Thread 0 runs again, it will eventually call `sem post()`, incrementing
  the value of the semaphore back to zero, and then wake the waiting thread
  (Thread 1), which will then be able to acquire the lock for itself.
* When Thread 1 finishes, it will again increment the value of the semaphore,
  restoring it to 1 again.

'''

* Figure 31.5 shows a trace of this example.
* In addition to thread actions, the figure shows the *scheduler state* of
  each thread: Run (the thread is running), Ready (i.e., runnable but not
  running), and Sleep (the thread is blocked).
* Note that Thread 1 goes into the sleeping state when it tries to acquire the
  already-held lock; only when Thread 0 runs again can Thread 1 be awoken and
  potentially run again.

.Thread Trace: Two Threads Using A Semaphore
image::figure-31-05.png[]

* If you want to work through your own example, try a scenario where multiple
  threads queue up waiting for a lock.
* What would the value of the semaphore be during such a trace?

'''

* Thus we are able to use semaphores as locks.
* Because locks only have two states (held and not held), we sometimes call a
  semaphore used as a lock a *binary semaphore*.
* Note that if you are using a semaphore only in this binary fashion, it could
  be implemented in a simpler manner than the generalized semaphores we
  present here.

== References

[D59] "A Note on Two Problems in Connexion with Graphs" by E. W. Dijkstra. Numerische Mathematik 1, 269-271, 1959. Available: `http://www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf`.::
* Can you believe people worked on algorithms in 1959?
* We can't.
* Even before computers were any fun to use, these people had a sense that
  they would transform the world...

[D68a] "Go-to Statement Considered Harmful" by E.W. Dijkstra. CACM, volume 11(3), March 1968. `http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF`.::
* Sometimes thought of as the beginning of the field of software engineering.

[D68b] "The Structure of the THE Multiprogramming System" by E.W. Dijkstra. CACM, volume 11(5), 1968.::
* One of the earliest papers to point out that systems work in computer
  science is an engaging intellectual endeavor.
* Also argues strongly for modularity in the form of layered systems.

[D72] "Information Streams Sharing a Finite Buffer" by E.W. Dijkstra.  Information Processing Letters 1, 1972.  `http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD329.PDF`.::
* Did Dijkstra invent everything?
* No, but maybe close.
* He certainly was the first to clearly write down what the problems were in
  concurrent code.
* However, practitioners in OS design knew of many of the problems described
  by Dijkstra, so perhaps giving him too much credit would be a
  misrepresentation.

[GR92] "Transaction Processing: Concepts and Techniques" by Jim Gray, Andreas Reuter. Morgan Kaufmann, September 1992.::
* The exact quote that we find particularly humorous is found on page 485, at
  the top of Section 8.8: "The first multiprocessors, circa 1960, had test and
  set instructions ... presumably the OS implementors worked out the appropriate
  algorithms, although Dijkstra is generally credited with inventing semaphores
  many years later."
* Oh, snap!
